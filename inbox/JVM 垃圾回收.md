---
date created: 2022-07-30, 07:16:35
date modified: 2022-08-03, 05:26:21
---

# Meta

- alias:
- parent :: [[MOC JVM]]
- siblings ::
- child ::
- refs:

---

垃圾回收（Garbage Collection，简称 GC）

主要关注堆空间的 GC。

# 如何判断哪些对象是垃圾？即什么状态的对象可回收

- 引用计数算法
    - 简单，但需要处理很多意外场景，比如对象的循环引用，故不用
    - 每个对象内部有一个引用计数器
- **可达性分析算法**（主流）
    - 从 GC Roots 不可达的对象即为可回收对象
    - 有哪些对象是 GC Roots？
        - Java 方法栈中引用的对象
        - 方法区中类静态属性引用的对象
        - 系统常用对象：比如基本数据类型对应的 Class 对象
        - 等等

# 垃圾收集算法

## 分代收集理论

程序运行经验法则：

- 绝大多数对象都是朝生夕灭的
- 熬过越多次垃圾收集的对象越难以消亡

根据上述经验法则，对 Java 堆划分不同的区域。

- Partial GC
    - Minor GC/young GC：只针对新生代的垃圾收集
    - Major GC/old GC：只针对老年代的垃圾收集
    - Mixed GC：收集整个新生代和部分老年代
- Full GC：针对整个 Java 堆和方法区的垃圾收集

## 标记 - 清除算法

- 标记所有可回收对象
- 清除被标记的对象

缺点：

- 清除后会产生内存碎片，后续若分配大对象时需要整理
- 当可回收对象数量较多时，清除时间成本较高

## 标记 - 复制算法

简称复制算法。

- 内存区域均分为两块 A 和 B，假设当前正常使用 A，B 区域暂作保留
- GC 时标记 A 中的可回收对象，直接复制到 B 中，整块清除 A

缺点：

- 内存空间浪费太多，只用了一半，另一半空闲
- 当存活对象数量较多时，复制时间成本较高

**HotSpot 针对新生代区域的 GC 采用改进式的复制算法：**

- 新生代按 `8:1:1` 比例划分成三块区域：Eden、Survivor_I、Survivor_II
- 每次分配内存只使用 Eden、Survivor_I
- GC 时将 Eden 和 Survivor_I 中仍存活对象一次性复制到 Survivor_II 中
- 清理 Eden、Survivor_I
- 当 Survivor_II 不足以容纳存活对象时，还可分配至 old 区

## 标记 - 整理算法

针对老年代对象特点（可存活对象数量多）的算法。

- 标记所有可回收对象
- 并非直接清除，而是整理移动，避免产生内存碎片

# 垃圾收集器
