---
date created: 2022-12-23, 10:14:20
date modified: 2022-12-23, 10:15:35
---

# Meta

- alias: Annotation Inheritance
- parent ::
- siblings ::
- child ::
- refs: 
    - [inheritance - How do Java method annotations work in conjunction with method overriding? - Stack Overflow](https://stackoverflow.com/questions/10082619/how-do-java-method-annotations-work-in-conjunction-with-method-overriding)
    - https://www.geeksforgeeks.org/inherited-annotations-in-java

---

当子类 override 父类的方法时，子类并不会继承父类方法上的注解以及参数注解。

当父类是 class 类型且在类名上的自定义注解带有 `@Inherited` 元注解时，子类 class 才能继承到父类上的自定义注解。

```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@interface CustomAnnotation {
    String value() default "GFG";
}

@CustomAnnotation(value = "Sky is limitless")
interface Super {
    @CustomAnnotation
    void foo();
}

class InheritedAnnotationDemo implements Super {
    @Override
    public void foo() {

    }

    public static void main(String[] arg) throws Exception {

        // Printing the annotation used to annotated the
        // Super and InheritedAnnotationDemo classes
        System.out.println(InheritedAnnotationDemo.class
        .getAnnotation(CustomAnnotation.class));

        System.out.println(InheritedAnnotationDemo.class
        .getDeclaredMethod("foo")
        .getAnnotation(CustomAnnotation.class));

        // As we haven't used the @Inherited Annotation to
        // create the custom annotation therefore not
        // inherited by InheritedAnnotationDemo class. When
        // we use getAnnotation() now, returns null.
        System.out.println(Super.class
        .getAnnotation(CustomAnnotation.class));

        // Obtaining the class class name and
        // printing the annotation info about the annotation
        // info attached to the Super class
        Class obj = Super.class;

        // Calling the Method 2 to
        // print the annotation state
        printAnnotationState(obj);
    }

    // Method 2
    // To print the annotation state
    static void printAnnotationState(AnnotatedElement ann) {

        // Obtaining all the annotations attached to the
        // passed element and storing it in an array
        Annotation[] annotationsArray
                = ann.getAnnotations();

        // Iterating on all the annotations stored inside of
        // the array above and printing their information
        for (Annotation annotation : annotationsArray) {

            // Print and display name and value of the
            // annotation
            System.out.println(
                    "Name of the annotation : "
                            + annotation.annotationType());
            System.out.println(
                    "Value : "
                            + ((CustomAnnotation) annotation).value());
        }
    }
}
```

什么时候遇到注解继承的问题？

背景：在项目中，为了方便其他微服务进行 [[Feign]] 调用，有一个 Feign 接口类，其中定义了该微服务 Controller 中的所有接口，且 Controller 实现了该 Feign 接口。

```java
@FeignClient
public interface User {
    @GetMapping
    UserInfo getUserInfo();
}

@RestController
public class UserController implements User {
    @Override
    public UserInfo getUserInfo() {
        // ...
    }
}
```

错误行为：在 Feign 接口中定义完新接口后，Controller 仅 Override 实现，没有标上例如 `@GetMapping` 等常规注解。结果实际调用时报 404 异常。

错误认知：以为子类继承了父类方法上的注解。

正确行为：像以前一样常规定义 Controller 中的接口，只是多加一个 `@Override` 注解而已。