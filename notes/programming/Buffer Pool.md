---
date created: 2022-06-24, 12:12:28
date modified: 2022-07-29, 11:54:13
---

# Meta

- alias:
- parent :: [[MOC MySQL]]
- siblings ::
- child ::
- refs: [MySQL 是怎样运行的：从根儿上理解 MySQL - 小孩子4919 - 掘金课程](https://juejin.cn/book/6844733769996304392/section/6844733770063429646)

---

一片连续的内存空间，用于缓存数据页。

# 内部组成

- 控制块：存储了每个缓存页的控制信息，比如该页所属表空间编号、页号、缓存页在 Buffer Pool 中的地址等
- 缓存页：对应磁盘页

# 内存管理以及内存与磁盘交互

3 个链表 + 一个哈希表。

## 空闲链表（free 链表）

- 为了表明 Buffer Pool 中哪些缓存页是空闲可用的
- 将空闲的缓存页对应的控制块串联形成一个链表

![CleanShot2022-07-29at11.28.30](https://pic-bed-615.oss-cn-beijing.aliyuncs.com/CleanShot%202022-07-29%20at%2011.28.30.png)

## 脏页链表（flush 链表）

- 为了表明 Buffer Pool 中哪些缓存页被修改过，需要写回磁盘
- 将被修改过的缓存页对应的控制块串联形成一个链表

## 分区 LRU 链表

- 为了提高缓存命中率
- 每当访问某个缓存页时，把该缓存页对应的控制块移动到 LRU 链表头部，当 Buffer Pool 空间不足时淘汰 LRU 链表末位控制块对应的缓存页（想象手机 APP 后台管理）

存在的问题（普通 LRU 缺点）：出现某些情况会将 Buffer Pool 中的常用页挤掉

- InnoDB 预读机制：加载可能被访问的缓存页（程序局部性原理）到 Buffer Pool 中，该页不一定被用到反而挤掉了常用页
- 执行全表扫描导致 Buffer Pool 中的页全被更换一次

解决方案：分区 LRU

- 分为 young 区（热数据）和 old 区（冷数据）
- 先放入 old 区，当该缓存页访问频繁（达到阈值）才移动到 young 区，优先淘汰 old 区的缓存页

## 已缓存页哈希表

- 为了快速判断某页是否在 Buffer Pool 中
- 用 `表空间号 + 页号`（可唯一确定一个页）作为 key，缓存页作为 value

# 多实例

支持多实例用以解决并发效率问题（细粒度锁）
