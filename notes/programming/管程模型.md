---
date created: 2021-12-29, 18:00:57
date modified: 2022-05-30, 17:26:32
---

# Meta

- parent :: [[并发理论]]
- siblings ::
- child ::
- refs:
    - [08 | 管程：并发编程的万能钥匙-极客时间](https://time.geekbang.org/column/article/86089)
    - [Monitor (synchronization) - Wikipedia](https://en.wikipedia.org/wiki/Monitor_(synchronization))

---

# 管程 Monitor

- 管程是一种解决并发问题的通用模型，可以通过编程语言提供的条件变量和互斥锁来实现。比如通过管程实现阻塞队列（[[如何实现一个阻塞队列]]）
- 管程能解决并发中互斥和同步问题
- 等价于 [[信号量模型]]

## 如何解决互斥问题？

封装共享数据结构和操作数据结构的方法，暴露唯一入口，多线程企图进入管程内部时，只允许一个线程进入，其他线程在入口等待队列阻塞。（入口有一个互斥锁）

## 如何解决同步问题？

引入条件变量，每个条件变量有对应的等待队列。（条件变量不满足时进入等待队列阻塞等待；条件变量满足时被唤醒出队）

## 三种管程模型

- Hasen 模型
- Hoare 模型
- **MESA 模型**
    - 在上面两种模型中，当 `A notify B`，B 线程会立即执行，即当 B 线程执行时，之前导致 B 阻塞的条件一定得到了满足，B 只需继续执行即可
    - 在 MESA 模型中，当 `A notify B`，B 线程只是从条件等待队列移到了入口等待队列中，在 B 执行之前可能有其他线程进入管程改变了条件，故 B 执行时还需要再次判断条件。（MESA 模型即 [[为什么 wait() 要放在循环里使用]] 的原因之一）
    - ![MESA 管程模型](https://pic-bed-615.oss-cn-beijing.aliyuncs.com/CleanShot%202022-06-07%20at%2018.55.16.png)

只有在 MESA 模型中提供了 `notifyAll`，另外两种模型中因为线程被唤醒后立马执行，提供不了 `notifyAll` 方法。
