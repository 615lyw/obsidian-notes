---
date created: 2022-05-09, 09:22:34
date modified: 2022-06-09, 11:31:16
---

# 什么是优先级队列？

实现元素按优先级排列（并非整体上有序），保证每次取出元素时都是优先级最高的元素。

> 计算机系统中经常会遇到这样一类问题：前一个任务已经执行完成，需要在待执行任务中挑选一个新的任务执行。
>
> 最简单的方法就是将所有的任务排成一个队列，按照队列的先进先出 (FIFO) 的策略挑选要执行的任务。这种策略虽然保证了所有的任务都能被执行，但是往往会导致执行时间短的或者紧急度高的任务在队列中等待时间较长而导致效率低下。
>
> 另一种策略是为每个任务安排一个优先级，每次挑选任务时只需要从队列中取出优先级最高的任务执行即可。实现该策略需要借助一种特殊的数据结构：优先级队列 (PriorityQueue)。

# Class PriorityQueue

- 优先级队列里的元素必须有优先级：优先级是前后排序的规则，类要么实现 Comparable，要么在构造函数处传入一个 [[Interface Comparator]]，不然运行时会报错
- 优先级队列的拥有小根堆的所有特性，若需大根堆，则传入逆序比较器
- **优先级队列不是线程安全的**，若要求线程安全，则使用 `Class PriorityBlockingQueue`
- 优先级队列不允许使用 null 元素
- 优先级队列本身并非一个有序（从 `a[0]-a[n]` 全部升序）序列，只有当你把元素一个个取出的时候，这些取出的元素所排成的序列才是有序序列。原因很简单，优先级队列是一个小根 [[堆]]，也就是只能保证根节点（a[0]）是最小的，其余元素的顺序不能保证（当然，其他元素必须遵守小根堆的特性），当我们取出元素（poll）时，我们只能取出根节点的元素，然后把堆的最后一个元素剪切到根节点（这种取出方式是底层算法规定的，充分利用了堆的特性），然后对所有剩余元素进行建堆，建堆之后根节点元素还是最小的（初始堆中的第二小）。由此特点，我们可以引出另外两个知识点：①优先级队列的迭代器遍历出来的数组是没有排序的，只是个小根堆。②如果我们想得到有序的堆，需要把堆先转为数组，然后 `arrays.sort(queue.toarray)`，`arrays.sort(queue.toarray, comparator 对象)` 或者其他 sort 方法

注：每个元素的优先级根据问题的要求而定。当从优先级队列中取出一个元素后，可能出现多个元素具有相同的优先权。在这种情况下，把这些具有相同优先权的元素视为一个先来先服务的队列，按他们的入队顺序进行先后处理。
