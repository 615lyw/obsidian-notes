---
date created: 2022-02-25, 21:29:36
date modified: 2022-05-30, 20:40:00
---

# Meta

- parent :: [[并发理论]]
- siblings ::
- child ::
- refs:
    - [jstack命令解析](https://mp.weixin.qq.com/s/MO9izjjB3bAWuBCt-Wg5Gg)

---

# 死锁

死锁：多个线程互相竞争资源的线程互相等待，导致永久阻塞。

## 一般什么情况下会出现死锁？

使用细粒度锁的场景，一般存在多个线程，多个互斥资源，每个线程可能需要请求多个资源。

因为死锁是因为多个线程竞争互斥资源，每个互斥资源都用一把锁保护，当获取不到所需资源对应锁时，互相阻塞导致死锁。

## 死锁的四个必要条件

四个条件都成立时便会发生死锁：

1. 互斥资源：共享资源只能被一个线程占用
2. 请求与保持：线程占有资源的同时请求别的所需资源，即线程不会自我放弃已有资源
3. 不可剥夺：线程已持有的资源不能被其他线程抢占
4. 循环等待：线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源

![](https://pic-bed-615.oss-cn-beijing.aliyuncs.com/NwuPJb.png)

## 如何预防死锁

破坏上述任一条件即可。

选择具体方案的时候，还需要评估一下操作成本，从中选择一个成本最低的方案。

1. 一次性申请所有资源
2. 占用资源的线程如果申请不到其他所需资源，主动释放已占用的资源
3. 资源按序申请

## 如何排查死锁问题

- jstack
- Java VisualVM
