---
date created: 2021-12-07, 15:42:22
date modified: 2022-06-09, 11:12:44
---

# Meta

- parent:: [[并发理论]]
- siblings::
- child::
- refs: [01 | 可见性、原子性和有序性问题：并发编程Bug的源头-极客时间](https://time.geekbang.org/column/article/83682)

---

为了缓解 CPU、内存、I/O 设备之间速度差异：

- CPU 增加缓存
- 操作系统分时复用 CPU
- 编译器（或解释器）重排 CPU 指令执行次序

# 缓存导致可见性问题

可见性：线程 A 修改共享变量值对于线程 B 是立即可见的。

可见性问题又可称为：[[缓存一致性问题]]

多核 CPU 时，每个 CPU 都有自己的缓存：

![3fxm9G](https://pic-bed-615.oss-cn-beijing.aliyuncs.com/3fxm9G.png)

内存中的共享变量会在多个 CPU 缓存中存在一份，此时线程 A 对于 CPU 缓存值的修改对于线程 B 是不可见的。

# 线程切换导致原子性问题

原子性：一个或多个操作在 CPU 执行过程中不被中断的特性。

操作系统分时调度线程执行，线程切换发生在 CPU 指令级别。

一条高级编程语言指令往往对应多条 CPU 指令，故一条高级语言指令执行可能并不满足原子性。

**我们需要在高级语言层面保证操作的原子性。**

通过 [[MOC 锁|锁]] 可以实现高级语言层面的原子性。

# 指令重排导致有序性问题

有序性：程序按照代码的先后顺序执行。

编译器和 CPU 为了优化性能，会对字节码和机器指令进行重排序。在单线程中，重排序后的指令执行结果与顺序执行结果一样。多线程中，重排序后的指令执行结果可能有问题。（[[竞态条件]]）

案例：[[单例模式 Singleton#4-懒汉式之 Double Check]] 可通过 [[volatile]] 禁止指令重排序。
